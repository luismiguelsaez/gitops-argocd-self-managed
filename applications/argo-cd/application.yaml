apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: argo-cd
  namespace: argocd
  annotations:
    argocd.argoproj.io/sync-options: Prune=false
    argocd.argoproj.io/sync-wave: "0"
spec:
  project: default
  destination:
    namespace: argocd
    server: https://kubernetes.default.svc
  syncPolicy:
    automated:
      prune: false
      selfHeal: true
      allowEmpty: false
    syncOptions:
      - CreateNamespace=true
      - Validate=true
      - RespectIgnoreDifferences=true
    retry:
      limit: 3
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 1m
  source:
    chart: argo-cd
    repoURL: https://argoproj.github.io/argo-helm
    targetRevision: 5.51.2
    helm:
      releaseName: argo-cd
      values: |
        global:
          additionalLabels:
            app: argo-cd
          revisionHistoryLimit: 3
          affinity: {}

        configs:
          cm:
            url: https://argocd.dev.lokalise.cloud
            exec.enabled: true
            admin.enabled: true
            timeout.reconciliation: 180s
            resource.customizations: |
              argoproj.io/Application:
                health.lua: |
                  hs = {}
                  hs.status = "Progressing"
                  hs.message = ""
                  if obj.status ~= nil then
                    if obj.status.health ~= nil then
                      hs.status = obj.status.health.status
                      if obj.status.health.message ~= nil then
                        hs.message = obj.status.health.message
                      end
                    end
                  end
                  return hs
            # Old format
            #resource.customizations.health.argoproj.io_Application: |
            #  hs = {}
            #  hs.status = "Progressing"
            #  hs.message = ""
            #  if obj.status ~= nil then
            #    if obj.status.health ~= nil then
            #      hs.status = obj.status.health.status
            #      if obj.status.health.message ~= nil then
            #        hs.message = obj.status.health.message
            #      end
            #    end
            #  end
            #  hs.message = "Waiting for Application"
            #  return hs
          params:
            server.insecure: true
            server.disable.auth: false
            controller.status.processors: 20
            controller.operation.processors: 10
            controller.self.heal.timeout.seconds: 5
            controller.repo.server.timeout.seconds: 60
            applicationsetcontroller.policy: sync
            applicationsetcontroller.enable.progressive.syncs: false
            reposerver.parallelism.limit: 0

        redis:
          enabled: true
          name: redis
          podLabels:
            app: redis
          resources:
            requests:
              cpu: 500m
              memory: 256Mi
            limits:
              cpu: 1000m
              memory: 512Mi
          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                  - matchExpressions:
                      - key: app
                        operator: In
                        values:
                          - redis

        redis-ha:
          enabled: true
          persistentVolume:
              enabled: false
              storageClass: ebs
              size: 10Gi
          redis:
            config:
              save: '"900 1"'
          haproxy:
            enabled: true
            hardAntiAffinity: true
            additionalAffinities:
              nodeAffinity:
                requiredDuringSchedulingIgnoredDuringExecution:
                  nodeSelectorTerms:
                    - matchExpressions:
                        - key: app
                          operator: In
                          values:
                            - redis
          topologySpreadConstraints:
            enabled: true
            maxSkew: 1
            topologyKey: topology.kubernetes.io/zone
            whenUnsatisfiable: DoNotSchedule
          hardAntiAffinity: true
          additionalAffinities:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                  - matchExpressions:
                      - key: app
                        operator: In
                        values:
                          - redis

        controller:
          replicas: 2
          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                  - matchExpressions:
                      - key: app
                        operator: In
                        values:
                          - argo-cd

        server:
          autoscaling:
            enabled: true
            minReplicas: 2
            maxReplicas: 4
          ingress:
            enabled: true
            ingressClassName: nginx-external
            hosts:
              - argocd.dev.lokalise.cloud
            paths:
              - /
            pathType: Prefix
            extraPaths: []
            tls: []

        repoServer:

          serviceAccount:
            create: true
            annotations:
              #eks.amazonaws.com/role-arn: arn:aws:iam::484308071187:role/helm-main-argocd
              eks.amazonaws.con/role-arn: <path:/eks/cluster/main/iam/roles/system#karpenter#AWSCURRENT>
            automountServiceAccountToken: true

          # CMP config - BEGIN
          env:
            - name: AVP_TYPE
              value: awssecretsmanager
          volumes:
            - name: cmp-kustomize-aws-secretsmanager
              configMap:
                name: cmp-kustomize-aws-secretsmanager
            - name: cmp-tmp
              emptyDir: {}
          extraContainers:
            - name: cmp-kustomize-aws-secretsmanager
              command:
                - "/var/run/argocd/argocd-cmp-server"
              args:
                - --loglevel
                - debug
                - --logformat
                - json
              image: luismiguelsaez/argocd-cmp-default:v0.0.2
              securityContext:
                runAsNonRoot: true
                runAsUser: 999
                runAsGroup: 999
              volumeMounts:
                - mountPath: /var/run/argocd
                  name: var-files
                - mountPath: /home/argocd/cmp-server/plugins
                  name: plugins
                - mountPath: /home/argocd/cmp-server/config/plugin.yaml
                  subPath: plugin.yaml
                  name: cmp-kustomize-aws-secretsmanager
                - mountPath: /tmp
                  name: cmp-tmp
              env:
                - name: AVP_TYPE
                  value: awssecretsmanager
                - name: HOME
                  value: "/tmp"
          # CMP config - END

          autoscaling:
            enabled: true
            minReplicas: 2
            maxReplicas: 5

          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                  - matchExpressions:
                      - key: app
                        operator: In
                        values:
                          - argo-cd

        applicationSet:
          replicas: 2

        extraObjects:

          - apiVersion: karpenter.sh/v1alpha5
            kind: Provisioner
            metadata:
              labels:
                app: argo-cd
              name: argo-cd
            spec:
              consolidation:
                enabled: true
              labels:
                app: argo-cd
              providerRef:
                name: bottlerocket-default
              requirements: [
                { key: karpenter.k8s.aws/instance-category, operator: In, values: [t]     },
                { key: kubernetes.io/arch,                  operator: In, values: [arm64] },
                { key: karpenter.sh/capacity-type,          operator: In, values: [spot]  },
                { key: kubernetes.io/os,                    operator: In, values: [linux] }
              ]

          - apiVersion: karpenter.sh/v1alpha5
            kind: Provisioner
            metadata:
              labels:
                app: redis
              name: redis
            spec:
              consolidation:
                enabled: true
              labels:
                app: redis
              providerRef:
                name: bottlerocket-default
              requirements: [
                { key: karpenter.k8s.aws/instance-category, operator: In, values: [t]     },
                { key: kubernetes.io/arch,                  operator: In, values: [arm64] },
                { key: karpenter.sh/capacity-type,          operator: In, values: [spot]  },
                { key: kubernetes.io/os,                    operator: In, values: [linux] }
              ]

          - apiVersion: v1
            kind: ConfigMap
            metadata:
              name: cmp-kustomize-aws-secretsmanager
            data:
              plugin.yaml: |
                apiVersion: argoproj.io/v1alpha1
                kind: ConfigManagementPlugin
                metadata:
                  name: cmp-kustomize-aws-secretsmanager
                spec:
                  version: v1.0
                  init:
                    command: [/bin/bash, -c]
                    args:
                      - |
                        find . -type f -name kustomization.yaml
                  generate:
                    command: [/bin/bash, -c]
                    args:
                      - |
                        kustomize build . | argocd-vault-plugin generate --verbose-sensitive-output -
                  discover:
                    find:
                      glob: "./**/kustomization.yaml"